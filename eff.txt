-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package eff
@version 0.0.0.0

module Control.Effect.Internal.Debug
debugEnabled :: Bool
type DebugCallStack = () :: Constraint
assertM :: (DebugCallStack, Applicative m) => Bool -> m ()

module Control.Effect.Internal.SmallArray
data SmallArray a
SmallArray :: SmallArray# a -> SmallArray a
data SmallMutableArray s a
SmallMutableArray :: SmallMutableArray# s a -> SmallMutableArray s a
newSmallArray :: (DebugCallStack, PrimMonad m) => Int -> a -> m (SmallMutableArray (PrimState m) a)
runSmallArray :: (forall s. () => ST s (SmallMutableArray s a)) -> SmallArray a

-- | Render a mutable array immutable.
--   
--   This operation performs no copying, so care must be taken not to
--   modify the input array after freezing.
unsafeFreezeSmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> m (SmallArray a)

-- | Render an immutable array mutable.
--   
--   This operation performs no copying, so care must be taken with its
--   use.
unsafeThawSmallArray :: PrimMonad m => SmallArray a -> m (SmallMutableArray (PrimState m) a)
sizeofSmallArray :: DebugCallStack => SmallArray a -> Int
sizeofSmallMutableArray :: DebugCallStack => SmallMutableArray s a -> Int
indexSmallArray :: DebugCallStack => SmallArray a -> Int -> (# a #)
readSmallArray :: (DebugCallStack, PrimMonad m) => SmallMutableArray (PrimState m) a -> Int -> m a
writeSmallArray :: (DebugCallStack, PrimMonad m) => SmallMutableArray (PrimState m) a -> Int -> a -> m ()
copySmallArray :: (DebugCallStack, PrimMonad m) => SmallMutableArray (PrimState m) a -> Int -> SmallArray a -> Int -> Int -> m ()
cloneSmallArray :: DebugCallStack => SmallArray a -> Int -> Int -> SmallArray a
copySmallMutableArray :: (DebugCallStack, PrimMonad m) => SmallMutableArray (PrimState m) a -> Int -> SmallMutableArray (PrimState m) a -> Int -> Int -> m ()
cloneSmallMutableArray :: (DebugCallStack, PrimMonad m) => SmallMutableArray (PrimState m) a -> Int -> Int -> m (SmallMutableArray (PrimState m) a)

module Control.Effect.Internal
axiom :: a :~: b

-- | A restricted form of <a>unsafeCoerce</a> that only works for
--   converting to/from <a>Any</a>. Still just as unsafe, but makes it
--   slightly more difficult to accidentally misuse.
pattern Any :: forall a. a -> Any
anyCo :: forall a. Coercion a Any

-- | Used to explicitly overwrite references to values that should not be
--   retained by the GC.
null# :: Any
unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
data Dict c
Dict :: Dict c
type family DictRep c
newtype WithDict c r
WithDict :: (c => r) -> WithDict c r
[unWithDict] :: WithDict c r -> c => r
reflectDict :: forall c r. DictRep c -> (c => r) -> r

-- | The kind of effects.
type Effect = (Type -> Type) -> Type -> Type
class eff :< effs
reifyIndex :: (:<) eff effs => Int
class effs1 :<< effs2
reifySubIndex :: (:<<) effs1 effs2 => Int
newtype eff :<# effs
ReflectIndex# :: Int# -> (:<#) eff effs
[reifyIndex#] :: (:<#) eff effs -> Int#
pattern IndexDict# :: forall eff effs. () => eff :< effs => eff :<# effs

-- | All <tt>eff</tt> computations operate in the <a>Eff</a> monad.
--   <a>Eff</a> computations are parameterized by a type-level list that
--   specifies which effects they are allowed to perform. For example, a
--   computation of type <tt><a>Eff</a> '[<a>Error</a> e, <a>Reader</a> r,
--   <a>State</a> s] a</tt> can raise exceptions of type <tt>e</tt>, can
--   access a global environment of type <tt>r</tt>, and can read and
--   modify a single cell of mutable state of type <tt>s</tt>.
--   
--   To run an <a>Eff</a> computation that performs effects, the effects
--   must be explicitly <i>handled</i>. Functions that handle effects are
--   called <i>effect handlers</i>, and they usually have types like the
--   following:
--   
--   <pre>
--   runX :: <a>Eff</a> (X ': effs) a -&gt; <a>Eff</a> effs a
--   </pre>
--   
--   Note that the argument to <tt>runX</tt> can perform the <tt>X</tt>
--   effect, but the result cannot! Any <tt>X</tt> operations have been
--   handled by <tt>runX</tt>, which interprets their meaning. Examples of
--   effect handlers include <a>runError</a>, <a>runReader</a>, and
--   <a>runState</a>.
--   
--   After all effects have been handled, the resulting computation will
--   have type <tt><a>Eff</a> '[] a</tt>, a computation that performs no
--   effects. A computation with this type is pure, so it can be converted
--   to an ordinary value using <a>run</a>.
--   
--   Some effects cannot be handled locally, but instead require performing
--   I/O. These effects will delegate to the <a>IOE</a> effect, which
--   provides low-level interop with Haskell’s built-in <a>IO</a> monad.
--   After all other effects have been handled, a computation of type
--   <tt><a>Eff</a> '[<a>IOE</a>] a</tt> can be converted to an ordinary
--   <tt><a>IO</a> a</tt> computation using <a>runIO</a>.
newtype Eff effs a
Eff# :: EVM a -> Eff effs a
[unEff#] :: Eff effs a -> EVM a
pattern Eff :: (Registers -> IO (Registers, a)) -> Eff effs a
newtype EVM a
EVM# :: (Registers# -> IO (Result a)) -> EVM a
[unEVM#] :: EVM a -> Registers# -> IO (Result a)
data Result a
Result :: Registers# -> ~a -> Result a
pattern EVM :: (Registers -> IO (Registers, a)) -> EVM a
packIOResult :: IO (Registers, a) -> IO (Result a)
newtype Registers#
Registers# :: (# PromptId, Targets# #) -> Registers#
data Registers
BoxRegisters :: Registers# -> Registers
[unboxRegisters] :: Registers -> Registers#
pattern Registers :: PromptId -> Targets -> Registers
initialRegisters :: Registers
newtype PromptId
PromptId# :: Int# -> PromptId
pattern PromptId :: Int -> PromptId
data Unwind
UnwindAbort :: PromptId -> ~Any -> Unwind
UnwindControl :: Capture Any -> Unwind
data Capture a
[Capture] :: PromptId -> CaptureMode -> ((b -> EVM c) -> EVM d) -> (b -> EVM a) -> Capture a
data CaptureMode

-- | The captured continuation should include the prompt being captured up
--   to. This mode corresponds to the <a>control</a> operator.
IncludePrompt :: CaptureMode

-- | The captured continuation should include frames up to the the prompt,
--   but not the prompt itself. This mode corresponds to the
--   <a>control0</a> operator.
ExcludePrompt :: CaptureMode
captureVM :: forall a b. Capture a -> IO b

-- | Runs an <a>EVM</a> action with a new prompt installed. The arguments
--   specify what happens when control exits the action.
promptVM :: forall a b. IO (Registers, a) -> (a -> IO b) -> (PromptId -> Any -> IO b) -> (Capture a -> IO b) -> IO b

-- | Like <a>promptVM</a>, but for prompts that cannot be the target of a
--   capture or abort (that is, prompts that only install
--   winders/unwinders).
promptVM_ :: forall a. IO (Registers, a) -> Registers -> (Capture a -> IO (Registers, a)) -> IO (Registers, a)
controlVM :: ((a -> EVM b) -> IO (Registers, b)) -> IO (Registers, a)
parameterizeVM :: (Registers -> Registers) -> EVM a -> EVM a
newtype Targets#
Targets# :: SmallArray# Any -> Targets#
newtype Targets
Targets :: SmallArray Any -> Targets
pattern BoxTargets :: Targets# -> Targets
noTargets :: Targets
lookupTarget :: forall effs eff. (DebugCallStack, eff :< effs) => Targets -> Handler eff
pushTarget :: Handler eff -> Targets -> Targets
dropTargets :: DebugCallStack => Int -> Targets -> Targets

-- | Runs a pure <a>Eff</a> computation to produce a value.
--   
--   <pre>
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>pure</a> 42
--   42
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>runError</a> <a>$</a> <a>throw</a> "bang"
--   <a>Left</a> "bang"
--   </pre>
run :: Eff '[] a -> a

-- | The monad that effect handlers run in.
--   
--   <ul>
--   <li>The <tt>eff</tt> parameter is the effect being handled, and the
--   <tt>effs</tt> parameter includes the other effects in scope at the
--   point of the <a>handle</a> call (used by <a>liftH</a>).</li>
--   <li>The <tt>i</tt> parameter is the return type of the handled
--   computation before the exit handler has been applied (used by
--   <a>control0</a>).</li>
--   <li>The <tt>r</tt> parameter is the final return type of the handled
--   computation (used by <a>abort</a>, <a>control</a>, and
--   <a>control0</a>).</li>
--   <li>The <tt>effs'</tt> parameter is the list of effects in scope at
--   the point of the originating <a>send</a> call (used by
--   <a>locally</a>).</li>
--   </ul>
--   
--   See <a>handle</a> for more details.
newtype Handle eff effs i r effs' a
Handle# :: (Registers# -> Eff effs' a) -> Handle eff effs i r effs' a
[runHandle#] :: Handle eff effs i r effs' a -> Registers# -> Eff effs' a
pattern Handle :: (Registers -> Eff effs' a) -> Handle eff effs i r effs' a
newtype Handler eff
Handler# :: (forall effs a. (eff :<# effs) -> eff (Eff effs) a -> Eff effs a) -> Handler eff
[runHandler#] :: Handler eff -> forall effs a. (eff :<# effs) -> eff (Eff effs) a -> Eff effs a
newtype WrappedHandler eff
WrapHandler :: (forall effs a. eff :< effs => eff (Eff effs) a -> Eff effs a) -> WrappedHandler eff
pattern Handler :: (forall effs a. eff :< effs => eff (Eff effs) a -> Eff effs a) -> Handler eff
send :: forall eff a effs. eff :< effs => eff (Eff effs) a -> Eff effs a

-- | Handles the topmost effect in an <a>Eff</a> computation. The given
--   handler function must provide an interpretation for each effectful
--   operation. The handler runs in the restrictive <a>Handle</a> monad,
--   which generally uses one of the following core <a>Handle</a>
--   operations:
--   
--   <ul>
--   <li><a>liftH</a> — Runs an action in the context of the original
--   <a>handle</a> call. This is the most common way to handle an
--   effect.</li>
--   <li><a>abort</a> — Aborts the computation to the <a>handle</a> call
--   and returns a value directly. This is usually used to implement
--   exception-like operations.</li>
--   <li><a>control</a> — Captures the current continuation up to and
--   including the <a>handle</a> call and aborts, passing the captured
--   continuation to the handler. This can be used to implement complex
--   control operators such as coroutines or resumable exceptions.</li>
--   <li><a>control0</a> — Like <a>control</a>, but does not include the
--   <a>handle</a> call itself in the captured continuation, so a different
--   handler may be installed before resuming the computation.</li>
--   <li><a>locally</a> — Runs an action directly in the context of the
--   originating <a>send</a> call. This can be used to implement “scoped”
--   operations like <a>local</a> and <a>catch</a>.</li>
--   </ul>
--   
--   See the documentation for each of the above functions for examples and
--   more details.
handle :: forall eff a r effs. (a -> Eff effs r) -> (forall effs' b. eff :< effs' => eff (Eff effs') b -> Handle eff effs a r effs' b) -> Eff (eff : effs) a -> Eff effs r
handleVM :: forall eff a r effs. (a -> Eff effs r) -> (Registers# -> Handler eff) -> Eff (eff : effs) a -> Eff effs r
locally :: Eff effs' a -> Handle eff effs i r effs' a
liftH :: Eff (eff : effs) a -> Handle eff effs i r effs' a
abort :: r -> Handle eff effs i r effs' a
control :: ((a -> Eff effs r) -> Eff effs r) -> Handle eff effs i r effs' a
control0 :: ((a -> Eff (eff : effs) i) -> Eff effs r) -> Handle eff effs i r effs' a
class Lift effs1 effs2
liftTargets :: Lift effs1 effs2 => Targets -> Targets

-- | Lifts an <a>Eff</a> computation into one that performs all the same
--   effects, and possibly more. For example, if you have a computation
--   
--   <pre>
--   m :: <a>Eff</a> '[Foo, Bar] ()
--   </pre>
--   
--   then <a>lift</a> will transform it into a polymorphic computation with
--   the following type:
--   
--   <pre>
--   <a>lift</a> m :: (Foo <a>:&lt;</a> effs, Bar <a>:&lt;</a> effs) =&gt; <a>Eff</a> effs ()
--   </pre>
--   
--   This type is much more general, and <tt>effs</tt> can now be
--   instantiated at many different types. Generally, <a>lift</a> can
--   manipulate the list of effects in any of the following ways:
--   
--   <ul>
--   <li>Effects can be reordered.</li>
--   <li>New effects can be inserted anywhere in the list.</li>
--   <li>Duplicate effects can be collapsed.</li>
--   </ul>
--   
--   More generally, the list of effects doesn’t need to be entirely
--   concrete in order for <a>lift</a> to work. For example, if you have a
--   computation
--   
--   <pre>
--   n :: <a>Eff</a> (Foo ': Bar ': effs1) ()
--   </pre>
--   
--   then <tt><a>lift</a> n</tt> will have the following type:
--   
--   <pre>
--   <a>lift</a> n :: (Foo <a>:&lt;</a> effs2, Bar <a>:&lt;</a> effs2, effs1 <a>:&lt;&lt;</a> effs2) =&gt; <a>Eff</a> effs2 ()
--   </pre>
--   
--   This type is extremely general, and it allows <a>lift</a> to
--   manipulate the <i>head</i> of the effects list even if the entire list
--   is not completely known.
--   
--   The <a>Lift</a> typeclass provides some type-level programming
--   machinery to implement <a>lift</a>, but it should be treated as an
--   implementation detail. In most situations, the machinery should “just
--   work,” but if it doesn’t, the type errors can be somewhat inscrutable.
--   In those situations, adding some explicit type annotations (or using
--   <tt>TypeApplications</tt>) can improve the type errors significantly.
lift :: forall effs1 effs2 a. Lift effs1 effs2 => Eff effs1 a -> Eff effs2 a

-- | Like <a>lift</a>, but restricted to introducing a single additional
--   effect in the result. This is behaviorally identical to just using
--   <a>lift</a>, but the restricted type can produce better type
--   inference.
lift1 :: forall eff effs a. Eff effs a -> Eff (eff : effs) a

-- | An effect used to run <a>IO</a> operations via <a>liftIO</a>. Handled
--   by the special <a>runIO</a> handler.
data IOE :: Effect
[LiftIO] :: IO a -> IOE m a
unsafeIOToEff :: IO a -> Eff effs a

-- | Converts an <a>Eff</a> computation to <a>IO</a>. Unlike most handlers,
--   <a>IOE</a> must be the final effect handled, and <a>runIO</a>
--   completely replaces the call to <a>run</a>.
runIO :: Eff '[IOE] a -> IO a

-- | The <tt><a>State</a> s</tt> effect provides access to a single cell of
--   mutable state of type <tt>s</tt>.
data State s :: Effect
[Get] :: State s m s
[Put] :: ~s -> State s m ()
evalState :: s -> Eff (State s : effs) a -> Eff effs a

-- | The <a>NonDet</a> effect provides so-called <i>nondeterministic
--   execution</i>, which runs all branches of a computation and collects
--   some or all of their results. Actual execution is not usually truly
--   nondeterministic in the sense that it is somehow random; rather,
--   <a>NonDet</a> models nondeterministic binary choice by executing
--   <i>both</i> possibilities rather than choosing just one.
data NonDet :: Effect
[Empty] :: NonDet m a
[Choose] :: NonDet m Bool
instance GHC.Base.Monad (Control.Effect.Internal.Eff effs)
instance GHC.Base.Applicative (Control.Effect.Internal.Eff effs)
instance GHC.Base.Functor (Control.Effect.Internal.Eff effs)
instance (Control.Effect.Internal.NonDet Control.Effect.Internal.:< effs) => GHC.Base.Alternative (Control.Effect.Internal.Eff effs)
instance (Control.Effect.Internal.IOE Control.Effect.Internal.:< effs) => Control.Monad.IO.Class.MonadIO (Control.Effect.Internal.Eff effs)
instance (effs1 Control.Effect.Internal.:<< effs2) => Control.Effect.Internal.Lift effs1 effs2
instance Control.Effect.Internal.Lift '[] effs
instance (eff Control.Effect.Internal.:< effs2, Control.Effect.Internal.Lift effs1 effs2) => Control.Effect.Internal.Lift (eff : effs1) effs2
instance GHC.Base.Functor (Control.Effect.Internal.Handle eff effs i r effs')
instance GHC.Base.Applicative (Control.Effect.Internal.Handle eff effs i r effs')
instance GHC.Base.Monad (Control.Effect.Internal.Handle eff effs i r effs')
instance GHC.Show.Show Control.Effect.Internal.Unwind
instance GHC.Exception.Type.Exception Control.Effect.Internal.Unwind
instance GHC.Base.Functor Control.Effect.Internal.EVM
instance GHC.Base.Applicative Control.Effect.Internal.EVM
instance GHC.Base.Monad Control.Effect.Internal.EVM
instance Control.Monad.IO.Class.MonadIO Control.Effect.Internal.EVM
instance effs Control.Effect.Internal.:<< effs
instance (effs2 GHC.Types.~ (eff : effs3), effs1 Control.Effect.Internal.:<< effs3) => effs1 Control.Effect.Internal.:<< effs2
instance eff Control.Effect.Internal.:< (eff : effs)
instance (eff Control.Effect.Internal.:< effs) => eff Control.Effect.Internal.:< (eff' : effs)


-- | This module exports the core functionality <tt>eff</tt> without any of
--   the built-in effects or effect handlers. You can import this module if
--   you don’t want to import the built-in effects, but otherwise you
--   probably want to import <a>Control.Effect</a> instead.
module Control.Effect.Base

-- | All <tt>eff</tt> computations operate in the <a>Eff</a> monad.
--   <a>Eff</a> computations are parameterized by a type-level list that
--   specifies which effects they are allowed to perform. For example, a
--   computation of type <tt><a>Eff</a> '[<a>Error</a> e, <a>Reader</a> r,
--   <a>State</a> s] a</tt> can raise exceptions of type <tt>e</tt>, can
--   access a global environment of type <tt>r</tt>, and can read and
--   modify a single cell of mutable state of type <tt>s</tt>.
--   
--   To run an <a>Eff</a> computation that performs effects, the effects
--   must be explicitly <i>handled</i>. Functions that handle effects are
--   called <i>effect handlers</i>, and they usually have types like the
--   following:
--   
--   <pre>
--   runX :: <a>Eff</a> (X ': effs) a -&gt; <a>Eff</a> effs a
--   </pre>
--   
--   Note that the argument to <tt>runX</tt> can perform the <tt>X</tt>
--   effect, but the result cannot! Any <tt>X</tt> operations have been
--   handled by <tt>runX</tt>, which interprets their meaning. Examples of
--   effect handlers include <a>runError</a>, <a>runReader</a>, and
--   <a>runState</a>.
--   
--   After all effects have been handled, the resulting computation will
--   have type <tt><a>Eff</a> '[] a</tt>, a computation that performs no
--   effects. A computation with this type is pure, so it can be converted
--   to an ordinary value using <a>run</a>.
--   
--   Some effects cannot be handled locally, but instead require performing
--   I/O. These effects will delegate to the <a>IOE</a> effect, which
--   provides low-level interop with Haskell’s built-in <a>IO</a> monad.
--   After all other effects have been handled, a computation of type
--   <tt><a>Eff</a> '[<a>IOE</a>] a</tt> can be converted to an ordinary
--   <tt><a>IO</a> a</tt> computation using <a>runIO</a>.
data Eff effs a

-- | Runs a pure <a>Eff</a> computation to produce a value.
--   
--   <pre>
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>pure</a> 42
--   42
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>runError</a> <a>$</a> <a>throw</a> "bang"
--   <a>Left</a> "bang"
--   </pre>
run :: Eff '[] a -> a

-- | Lifts an <a>Eff</a> computation into one that performs all the same
--   effects, and possibly more. For example, if you have a computation
--   
--   <pre>
--   m :: <a>Eff</a> '[Foo, Bar] ()
--   </pre>
--   
--   then <a>lift</a> will transform it into a polymorphic computation with
--   the following type:
--   
--   <pre>
--   <a>lift</a> m :: (Foo <a>:&lt;</a> effs, Bar <a>:&lt;</a> effs) =&gt; <a>Eff</a> effs ()
--   </pre>
--   
--   This type is much more general, and <tt>effs</tt> can now be
--   instantiated at many different types. Generally, <a>lift</a> can
--   manipulate the list of effects in any of the following ways:
--   
--   <ul>
--   <li>Effects can be reordered.</li>
--   <li>New effects can be inserted anywhere in the list.</li>
--   <li>Duplicate effects can be collapsed.</li>
--   </ul>
--   
--   More generally, the list of effects doesn’t need to be entirely
--   concrete in order for <a>lift</a> to work. For example, if you have a
--   computation
--   
--   <pre>
--   n :: <a>Eff</a> (Foo ': Bar ': effs1) ()
--   </pre>
--   
--   then <tt><a>lift</a> n</tt> will have the following type:
--   
--   <pre>
--   <a>lift</a> n :: (Foo <a>:&lt;</a> effs2, Bar <a>:&lt;</a> effs2, effs1 <a>:&lt;&lt;</a> effs2) =&gt; <a>Eff</a> effs2 ()
--   </pre>
--   
--   This type is extremely general, and it allows <a>lift</a> to
--   manipulate the <i>head</i> of the effects list even if the entire list
--   is not completely known.
--   
--   The <a>Lift</a> typeclass provides some type-level programming
--   machinery to implement <a>lift</a>, but it should be treated as an
--   implementation detail. In most situations, the machinery should “just
--   work,” but if it doesn’t, the type errors can be somewhat inscrutable.
--   In those situations, adding some explicit type annotations (or using
--   <tt>TypeApplications</tt>) can improve the type errors significantly.
lift :: forall effs1 effs2 a. Lift effs1 effs2 => Eff effs1 a -> Eff effs2 a

-- | Like <a>lift</a>, but restricted to introducing a single additional
--   effect in the result. This is behaviorally identical to just using
--   <a>lift</a>, but the restricted type can produce better type
--   inference.
lift1 :: forall eff effs a. Eff effs a -> Eff (eff : effs) a

-- | The kind of effects.
type Effect = (Type -> Type) -> Type -> Type
send :: forall eff a effs. eff :< effs => eff (Eff effs) a -> Eff effs a
class eff :< effs
class effs1 :<< effs2

-- | The simplest way to handle an effect. Each use of <a>send</a> for the
--   handled effect dispatches to the handler function, which provides an
--   interpretation for the operation. The handler function may handle the
--   operation directly, or it may defer to other effects currently in
--   scope.
--   
--   Most effect handlers should be implemented using <a>interpret</a>,
--   possibly with the help of additional <a>Error</a> or <a>State</a>
--   effects. Especially complex handlers can be defined via the more
--   general <a>handle</a>, which <a>interpret</a> is defined in terms of:
--   
--   <pre>
--   <a>interpret</a> f = <a>handle</a> (<a>liftH</a> <a>.</a> f)
--   </pre>
interpret :: forall eff a effs. (forall m b. eff m b -> Eff (eff : effs) b) -> Eff (eff : effs) a -> Eff effs a

-- | The monad that effect handlers run in.
--   
--   <ul>
--   <li>The <tt>eff</tt> parameter is the effect being handled, and the
--   <tt>effs</tt> parameter includes the other effects in scope at the
--   point of the <a>handle</a> call (used by <a>liftH</a>).</li>
--   <li>The <tt>i</tt> parameter is the return type of the handled
--   computation before the exit handler has been applied (used by
--   <a>control0</a>).</li>
--   <li>The <tt>r</tt> parameter is the final return type of the handled
--   computation (used by <a>abort</a>, <a>control</a>, and
--   <a>control0</a>).</li>
--   <li>The <tt>effs'</tt> parameter is the list of effects in scope at
--   the point of the originating <a>send</a> call (used by
--   <a>locally</a>).</li>
--   </ul>
--   
--   See <a>handle</a> for more details.
data Handle eff effs i r effs' a

-- | Handles the topmost effect in an <a>Eff</a> computation. The given
--   handler function must provide an interpretation for each effectful
--   operation. The handler runs in the restrictive <a>Handle</a> monad,
--   which generally uses one of the following core <a>Handle</a>
--   operations:
--   
--   <ul>
--   <li><a>liftH</a> — Runs an action in the context of the original
--   <a>handle</a> call. This is the most common way to handle an
--   effect.</li>
--   <li><a>abort</a> — Aborts the computation to the <a>handle</a> call
--   and returns a value directly. This is usually used to implement
--   exception-like operations.</li>
--   <li><a>control</a> — Captures the current continuation up to and
--   including the <a>handle</a> call and aborts, passing the captured
--   continuation to the handler. This can be used to implement complex
--   control operators such as coroutines or resumable exceptions.</li>
--   <li><a>control0</a> — Like <a>control</a>, but does not include the
--   <a>handle</a> call itself in the captured continuation, so a different
--   handler may be installed before resuming the computation.</li>
--   <li><a>locally</a> — Runs an action directly in the context of the
--   originating <a>send</a> call. This can be used to implement “scoped”
--   operations like <a>local</a> and <a>catch</a>.</li>
--   </ul>
--   
--   See the documentation for each of the above functions for examples and
--   more details.
handle :: forall eff a r effs. (a -> Eff effs r) -> (forall effs' b. eff :< effs' => eff (Eff effs') b -> Handle eff effs a r effs' b) -> Eff (eff : effs) a -> Eff effs r
liftH :: Eff (eff : effs) a -> Handle eff effs i r effs' a
abort :: r -> Handle eff effs i r effs' a
control :: ((a -> Eff effs r) -> Eff effs r) -> Handle eff effs i r effs' a
control0 :: ((a -> Eff (eff : effs) i) -> Eff effs r) -> Handle eff effs i r effs' a
locally :: Eff effs' a -> Handle eff effs i r effs' a

-- | An effect used to run <a>IO</a> operations via <a>liftIO</a>. Handled
--   by the special <a>runIO</a> handler.
data IOE :: Effect
[LiftIO] :: IO a -> IOE m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Converts an <a>Eff</a> computation to <a>IO</a>. Unlike most handlers,
--   <a>IOE</a> must be the final effect handled, and <a>runIO</a>
--   completely replaces the call to <a>run</a>.
runIO :: Eff '[IOE] a -> IO a

module Control.Effect.Error

-- | The <tt><a>Error</a> e</tt> effect allows throwing and catching errors
--   of type <tt>e</tt>.
--   
--   Handlers should obey the law <tt><a>catch</a> (<a>throw</a> <i>x</i>)
--   <i>f</i></tt> ≡ <tt><a>pure</a> (<i>f</i> <i>x</i>)</tt>.
data Error e :: Effect
[Throw] :: e -> Error e m a
[Catch] :: Eff (Error e : effs) a -> (e -> Eff effs a) -> Error e (Eff effs) a

-- | Raises an error of type <tt>e</tt>.
throw :: Error e :< effs => e -> Eff effs a

-- | <tt><a>catch</a> <i>m</i> <i>f</i></tt> executes <tt><i>m</i></tt>. If
--   it raises an error <tt><i>e</i></tt>, the computation aborts to the
--   point of the call to <a>catch</a>, and it resumes by executing
--   <tt><i>f</i> <i>e</i></tt>.
catch :: Error e :< effs => Eff (Error e : effs) a -> (e -> Eff effs a) -> Eff effs a

-- | Handles an <a>Error</a> effect. Returns <a>Left</a> if the computation
--   raised an uncaught error, otherwise returns <a>Right</a>.
runError :: forall e a effs. Eff (Error e : effs) a -> Eff effs (Either e a)

module Control.Effect.Coroutine
data Coroutine a b :: Effect
[Yield] :: a -> Coroutine a b m b
yield :: Coroutine a b :< effs => a -> Eff effs b
data Status effs a b c
Done :: c -> Status effs a b c
Yielded :: a -> !b -> Eff (Coroutine a b : effs) c -> Status effs a b c
runCoroutine :: Eff (Coroutine a b : effs) c -> Eff effs (Status effs a b c)

module Control.Effect.NonDet

-- | The <a>NonDet</a> effect provides so-called <i>nondeterministic
--   execution</i>, which runs all branches of a computation and collects
--   some or all of their results. Actual execution is not usually truly
--   nondeterministic in the sense that it is somehow random; rather,
--   <a>NonDet</a> models nondeterministic binary choice by executing
--   <i>both</i> possibilities rather than choosing just one.
data NonDet :: Effect
[Empty] :: NonDet m a
[Choose] :: NonDet m Bool

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Handles a <a>NonDet</a> effect, collecting the results of all branches
--   of the computation. The results are collected <b>strictly</b>, which
--   means that <i>all</i> effects are evaluated (even if using an
--   <a>Alternative</a> that ignores subsequent results, such as
--   <a>Maybe</a>).
--   
--   The result is also built using a <b>left-associated</b> sequence of
--   <a>&lt;|&gt;</a> calls, which allows the result to be constructed in
--   constant space if an appropriate <a>Alternative</a> instance is used,
--   but can lead to very poor performance for types with inefficient
--   append operations, such as <tt>[]</tt>. Consider using a data
--   structure that supports efficient appends, such as
--   <tt>Data.Sequence.Seq</tt>.
runNonDetAll :: Alternative f => Eff (NonDet : effs) a -> Eff effs (f a)

module Control.Effect.Reader

-- | The <tt><a>Reader</a> r</tt> effect provides access to a global
--   environment of type <tt>r</tt>.
--   
--   Handlers should obey the law <tt><i>f</i> <a>&lt;$&gt;</a>
--   <a>ask</a></tt> ≡ <tt><a>local</a> <i>f</i> <a>ask</a></tt>.
data Reader r :: Effect
[Ask] :: Reader r m r
[Local] :: (r1 -> r2) -> Eff (Reader r2 : effs) a -> Reader r1 (Eff effs) a

-- | Retrieves a value from the environment.
ask :: Reader r :< effs => Eff effs r

-- | Runs a subcomputation in an environment modified by the given
--   function.
local :: Reader r1 :< effs => (r1 -> r2) -> Eff (Reader r2 : effs) a -> Eff effs a

-- | Handles a <tt><a>Reader</a></tt> effect by supplying a value for the
--   environment.
runReader :: r -> Eff (Reader r : effs) a -> Eff effs a

module Control.Effect.State

-- | The <tt><a>State</a> s</tt> effect provides access to a single cell of
--   mutable state of type <tt>s</tt>.
data State s :: Effect
[Get] :: State s m s
[Put] :: ~s -> State s m ()

-- | Retrieves the current value of the state.
get :: State s :< effs => Eff effs s

-- | Replaces the current state with the given value.
put :: State s :< effs => s -> Eff effs ()

-- | Modifies the current state by applying the given function to it.
modify :: State s :< effs => (s -> s) -> Eff effs ()

module Control.Effect.State.Strict

-- | Handles a <tt><a>State</a></tt> effect using a strict cell of mutable
--   state—each use of <a>put</a> or <a>modify</a> eagerly forces the new
--   value. The state is initialized to the given value, and the final
--   state is returned alongside the computation’s result.
runState :: s -> Eff (State s : effs) a -> Eff effs (s, a)
evalState :: s -> Eff (State s : effs) a -> Eff effs a
execState :: s -> Eff (State s : effs) a -> Eff effs s

module Control.Effect.Writer

-- | The <tt><a>Writer</a> w</tt> effect allows the accumulation of
--   monoidal values of type <tt>w</tt>.
--   
--   Instances should obey the following laws:
--   
--   <ul>
--   <li><tt><a>tell</a> <i>x</i> <a>*&gt;</a> <a>tell</a> <i>y</i></tt> ≡
--   <tt><a>tell</a> (<i>x</i> <a>&lt;&gt;</a> <i>y</i>)</tt></li>
--   <li><tt><a>listen</a> (<a>tell</a> <i>x</i>)</tt> ≡ <tt>(<i>x</i>,)
--   <a>&lt;$&gt;</a> <a>tell</a> <i>x</i></tt></li>
--   <li><tt><a>censor</a> <i>f</i> (<a>tell</a> <i>x</i>)</tt> ≡
--   <tt><a>tell</a> (<i>f</i> <i>x</i>)</tt></li>
--   </ul>
data Writer w :: Effect
[Tell] :: w -> Writer w m ()
[Listen] :: Eff (Writer w : effs) a -> Writer w (Eff effs) (w, a)
[Censor] :: (w -> w) -> Eff (Writer w : effs) a -> Writer w (Eff effs) a

-- | Appends the given value to the current output.
tell :: Writer w :< effs => w -> Eff effs ()

-- | Executes the given action and includes its output in the result.
listen :: Writer w :< effs => Eff (Writer w : effs) a -> Eff effs (w, a)

-- | Executes the given action and modifies its output by applying the
--   given function.
censor :: Writer w :< effs => (w -> w) -> Eff (Writer w : effs) a -> Eff effs a

module Control.Effect.Writer.Strict

-- | Handles a <tt><a>Writer</a></tt> effect, strictly accumulating the
--   monoidal state.
--   
--   Note that the state will be accumulated via <b>left-associated</b>
--   uses of <a>&lt;&gt;</a>. This is necessary to be strict, but it can be
--   catastrophically slow on certain monoids, most notably <tt>[]</tt>. To
--   avoid pathological performance, use a data structure that supports
--   efficient appends, such as <tt>Data.Sequence.Seq</tt>, or use
--   <a>Dual</a> to flip the argument order of <a>&lt;&gt;</a> (but beware
--   that this will cause the elements to be accumulated in reverse order).
runWriter :: Monoid w => Eff (Writer w : effs) a -> Eff effs (w, a)
evalWriter :: Monoid w => Eff (Writer w : effs) a -> Eff effs a
execWriter :: Monoid w => Eff (Writer w : effs) a -> Eff effs w


-- | <tt>eff</tt> is a fast, flexible, easy to use effect system for
--   Haskell. <tt>eff</tt> makes it easy to write composable, modular
--   effects and effect handlers without sacrificing performance. Broadly
--   speaking, <tt>eff</tt> provides the following features:
--   
--   <ul>
--   <li>The <a>Eff</a> monad, which provides an extremely flexible set of
--   control operations that can be used to implement a variety of
--   effects.</li>
--   <li>A standard library of built-in effects and effect handlers,
--   including common effects like <a>Reader</a>, <a>State</a>, and
--   <a>Error</a>.</li>
--   <li>A framework for defining your own effects and effect handlers,
--   which can either be built from scratch using the <a>Eff</a> primitives
--   or by delegating to an existing handler.</li>
--   </ul>
--   
--   <tt>eff</tt> is far from the first effect system for Haskell, but it
--   differentiates itself from existing libraries in the following
--   respects:
--   
--   <ul>
--   <li><tt>eff</tt> is built atop a direct, low-level implementation of
--   delimited continuations to provide the best performance possible.</li>
--   <li><tt>eff</tt> provides a simpler, more streamlined API for handling
--   effects.</li>
--   <li>Like <tt>polysemy</tt> and <tt>fused-effects</tt> (but unlike
--   <tt>freer-simple</tt>), <tt>eff</tt> supports so called “scoped”
--   effect operations like <a>local</a> and <a>catch</a>, but unlike
--   <tt>polysemy</tt> and <tt>fused-effects</tt> (and also unlike
--   <tt>transformers</tt>/<tt>mtl</tt>), <tt>eff</tt> provides a
--   consistent semantics for such operations regardless of handler
--   order.</li>
--   </ul>
--   
--   <tt>eff</tt> aspires to be a turnkey replacement for most traditional
--   uses of monad transformers. <tt>eff</tt> provides comparable
--   performance to <tt>transformers</tt> and <tt>mtl</tt> with less
--   complexity, less boilerplate, and a simpler semantics.
module Control.Effect

-- | All <tt>eff</tt> computations operate in the <a>Eff</a> monad.
--   <a>Eff</a> computations are parameterized by a type-level list that
--   specifies which effects they are allowed to perform. For example, a
--   computation of type <tt><a>Eff</a> '[<a>Error</a> e, <a>Reader</a> r,
--   <a>State</a> s] a</tt> can raise exceptions of type <tt>e</tt>, can
--   access a global environment of type <tt>r</tt>, and can read and
--   modify a single cell of mutable state of type <tt>s</tt>.
--   
--   To run an <a>Eff</a> computation that performs effects, the effects
--   must be explicitly <i>handled</i>. Functions that handle effects are
--   called <i>effect handlers</i>, and they usually have types like the
--   following:
--   
--   <pre>
--   runX :: <a>Eff</a> (X ': effs) a -&gt; <a>Eff</a> effs a
--   </pre>
--   
--   Note that the argument to <tt>runX</tt> can perform the <tt>X</tt>
--   effect, but the result cannot! Any <tt>X</tt> operations have been
--   handled by <tt>runX</tt>, which interprets their meaning. Examples of
--   effect handlers include <a>runError</a>, <a>runReader</a>, and
--   <a>runState</a>.
--   
--   After all effects have been handled, the resulting computation will
--   have type <tt><a>Eff</a> '[] a</tt>, a computation that performs no
--   effects. A computation with this type is pure, so it can be converted
--   to an ordinary value using <a>run</a>.
--   
--   Some effects cannot be handled locally, but instead require performing
--   I/O. These effects will delegate to the <a>IOE</a> effect, which
--   provides low-level interop with Haskell’s built-in <a>IO</a> monad.
--   After all other effects have been handled, a computation of type
--   <tt><a>Eff</a> '[<a>IOE</a>] a</tt> can be converted to an ordinary
--   <tt><a>IO</a> a</tt> computation using <a>runIO</a>.
data Eff effs a

-- | Runs a pure <a>Eff</a> computation to produce a value.
--   
--   <pre>
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>pure</a> 42
--   42
--   &gt;&gt;&gt; <a>run</a> <a>$</a> <a>runError</a> <a>$</a> <a>throw</a> "bang"
--   <a>Left</a> "bang"
--   </pre>
run :: Eff '[] a -> a

-- | Lifts an <a>Eff</a> computation into one that performs all the same
--   effects, and possibly more. For example, if you have a computation
--   
--   <pre>
--   m :: <a>Eff</a> '[Foo, Bar] ()
--   </pre>
--   
--   then <a>lift</a> will transform it into a polymorphic computation with
--   the following type:
--   
--   <pre>
--   <a>lift</a> m :: (Foo <a>:&lt;</a> effs, Bar <a>:&lt;</a> effs) =&gt; <a>Eff</a> effs ()
--   </pre>
--   
--   This type is much more general, and <tt>effs</tt> can now be
--   instantiated at many different types. Generally, <a>lift</a> can
--   manipulate the list of effects in any of the following ways:
--   
--   <ul>
--   <li>Effects can be reordered.</li>
--   <li>New effects can be inserted anywhere in the list.</li>
--   <li>Duplicate effects can be collapsed.</li>
--   </ul>
--   
--   More generally, the list of effects doesn’t need to be entirely
--   concrete in order for <a>lift</a> to work. For example, if you have a
--   computation
--   
--   <pre>
--   n :: <a>Eff</a> (Foo ': Bar ': effs1) ()
--   </pre>
--   
--   then <tt><a>lift</a> n</tt> will have the following type:
--   
--   <pre>
--   <a>lift</a> n :: (Foo <a>:&lt;</a> effs2, Bar <a>:&lt;</a> effs2, effs1 <a>:&lt;&lt;</a> effs2) =&gt; <a>Eff</a> effs2 ()
--   </pre>
--   
--   This type is extremely general, and it allows <a>lift</a> to
--   manipulate the <i>head</i> of the effects list even if the entire list
--   is not completely known.
--   
--   The <a>Lift</a> typeclass provides some type-level programming
--   machinery to implement <a>lift</a>, but it should be treated as an
--   implementation detail. In most situations, the machinery should “just
--   work,” but if it doesn’t, the type errors can be somewhat inscrutable.
--   In those situations, adding some explicit type annotations (or using
--   <tt>TypeApplications</tt>) can improve the type errors significantly.
lift :: forall effs1 effs2 a. Lift effs1 effs2 => Eff effs1 a -> Eff effs2 a

-- | Like <a>lift</a>, but restricted to introducing a single additional
--   effect in the result. This is behaviorally identical to just using
--   <a>lift</a>, but the restricted type can produce better type
--   inference.
lift1 :: forall eff effs a. Eff effs a -> Eff (eff : effs) a

-- | The kind of effects.
type Effect = (Type -> Type) -> Type -> Type
send :: forall eff a effs. eff :< effs => eff (Eff effs) a -> Eff effs a
class eff :< effs
class effs1 :<< effs2

-- | The simplest way to handle an effect. Each use of <a>send</a> for the
--   handled effect dispatches to the handler function, which provides an
--   interpretation for the operation. The handler function may handle the
--   operation directly, or it may defer to other effects currently in
--   scope.
--   
--   Most effect handlers should be implemented using <a>interpret</a>,
--   possibly with the help of additional <a>Error</a> or <a>State</a>
--   effects. Especially complex handlers can be defined via the more
--   general <a>handle</a>, which <a>interpret</a> is defined in terms of:
--   
--   <pre>
--   <a>interpret</a> f = <a>handle</a> (<a>liftH</a> <a>.</a> f)
--   </pre>
interpret :: forall eff a effs. (forall m b. eff m b -> Eff (eff : effs) b) -> Eff (eff : effs) a -> Eff effs a

-- | The monad that effect handlers run in.
--   
--   <ul>
--   <li>The <tt>eff</tt> parameter is the effect being handled, and the
--   <tt>effs</tt> parameter includes the other effects in scope at the
--   point of the <a>handle</a> call (used by <a>liftH</a>).</li>
--   <li>The <tt>i</tt> parameter is the return type of the handled
--   computation before the exit handler has been applied (used by
--   <a>control0</a>).</li>
--   <li>The <tt>r</tt> parameter is the final return type of the handled
--   computation (used by <a>abort</a>, <a>control</a>, and
--   <a>control0</a>).</li>
--   <li>The <tt>effs'</tt> parameter is the list of effects in scope at
--   the point of the originating <a>send</a> call (used by
--   <a>locally</a>).</li>
--   </ul>
--   
--   See <a>handle</a> for more details.
data Handle eff effs i r effs' a

-- | Handles the topmost effect in an <a>Eff</a> computation. The given
--   handler function must provide an interpretation for each effectful
--   operation. The handler runs in the restrictive <a>Handle</a> monad,
--   which generally uses one of the following core <a>Handle</a>
--   operations:
--   
--   <ul>
--   <li><a>liftH</a> — Runs an action in the context of the original
--   <a>handle</a> call. This is the most common way to handle an
--   effect.</li>
--   <li><a>abort</a> — Aborts the computation to the <a>handle</a> call
--   and returns a value directly. This is usually used to implement
--   exception-like operations.</li>
--   <li><a>control</a> — Captures the current continuation up to and
--   including the <a>handle</a> call and aborts, passing the captured
--   continuation to the handler. This can be used to implement complex
--   control operators such as coroutines or resumable exceptions.</li>
--   <li><a>control0</a> — Like <a>control</a>, but does not include the
--   <a>handle</a> call itself in the captured continuation, so a different
--   handler may be installed before resuming the computation.</li>
--   <li><a>locally</a> — Runs an action directly in the context of the
--   originating <a>send</a> call. This can be used to implement “scoped”
--   operations like <a>local</a> and <a>catch</a>.</li>
--   </ul>
--   
--   See the documentation for each of the above functions for examples and
--   more details.
handle :: forall eff a r effs. (a -> Eff effs r) -> (forall effs' b. eff :< effs' => eff (Eff effs') b -> Handle eff effs a r effs' b) -> Eff (eff : effs) a -> Eff effs r
liftH :: Eff (eff : effs) a -> Handle eff effs i r effs' a
abort :: r -> Handle eff effs i r effs' a
control :: ((a -> Eff effs r) -> Eff effs r) -> Handle eff effs i r effs' a
control0 :: ((a -> Eff (eff : effs) i) -> Eff effs r) -> Handle eff effs i r effs' a
locally :: Eff effs' a -> Handle eff effs i r effs' a

-- | An effect used to run <a>IO</a> operations via <a>liftIO</a>. Handled
--   by the special <a>runIO</a> handler.
data IOE :: Effect
[LiftIO] :: IO a -> IOE m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Converts an <a>Eff</a> computation to <a>IO</a>. Unlike most handlers,
--   <a>IOE</a> must be the final effect handled, and <a>runIO</a>
--   completely replaces the call to <a>run</a>.
runIO :: Eff '[IOE] a -> IO a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Left-to-right composition
(>>>) :: forall k cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
